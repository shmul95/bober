#!/usr/bin/env python3
import os
import time
import json
import numpy as np
import pygame
from collections import deque
from pyvesc.VESC import VESC

# --- CONFIGURATION ---
ACTION_CFG_PATH  = "action_config.json"
DIST_FILE_PATH   = os.path.join("camera", "data", "distance.txt")
NB_RAYCAST       = 60
SMOOTH_FRAMES    = 3

# joystick mapping
BUTTON_A         = 0   # pause / resume
BUTTON_B         = 1   # toggle manual/autopilot
AXIS_STEER       = 0
AXIS_LT          = 2
AXIS_RT          = 5

# manual drive parameters
MAX_SPEED        = 0.20
REVERSE_SPEED    = -0.05
STEERING_CENTER  = 0.5
STEERING_RANGE   = 1.0

#auto
MAX_AUTO_SPEED   = 0.04
MIN_AUTO_SPEED   = 0.02

# ramp config for speed (autopilot only)
MAX_ACCEL_STEP   = 0.01
LOOP_DELAY       = 0.01  # seconds (~100 Hz)

def load_config():
    with open(ACTION_CFG_PATH) as f:
        return json.load(f)

def ramp_speed(target: float, current: float, step: float, allow_negative: bool=False) -> float:
    delta = target - current
    if abs(delta) > step:
        current += step * np.sign(delta)
    else:
        current = target
    if not allow_negative and current < 0.0:
        current = 0.0
    return current

def get_action(vis: np.ndarray, cfg: dict, is_reversing: bool):
    max_speed      = cfg["MAX_SPEED"]
    min_speed      = cfg["MIN_SPEED"]
    max_steering   = cfg["STEERING"]
    steering_thr   = cfg["STEERING_THRESHOLD"]
    steer_deadzone = cfg.get("STEER_DEADZONE", 0.0)
    max_vision     = cfg["MAX_VISION"]
    min_vision     = cfg["MIN_VISION"]
    brake_thr      = cfg["BRAKE_THRESHOLD"]
    brake_force    = cfg["BRAKE_FORCE"]
    start_rev      = cfg["START_REVERSE"]
    stop_rev       = cfg["STOP_REVERSE"]
    boost          = cfg["BOOST"]
    boost_thr      = cfg["BOOST_THRESHOLD"]

    if vis is None:
        return np.array([[0.0, 0.0]], dtype=np.float32), is_reversing

    mean_vis = vis.mean()
    half     = len(vis) // 2
    front    = vis[half-1:half+1].mean()
    left     = vis[:half].mean()
    right    = vis[half:].mean()

    vision_history.append(front)
    dist_delta = vision_history[0] - front
    do_boost   = boost if abs(dist_delta) < boost_thr else 0.0

    if (left < start_rev or right < start_rev) and not is_reversing:
        is_reversing = True
    elif (left > stop_rev and right > stop_rev) and is_reversing:
        is_reversing = False

    if is_reversing:
        speed = 0.0
    else:
        if dist_delta > brake_thr:
            speed = brake_force
        else:
            norm = np.clip((front - min_vision) / (max_vision - min_vision), 0.0, 1.0)
            speed = min_speed + norm * (max_speed - min_speed)

    if mean_vis < steering_thr:
        x = int(vis.argmax())
        steering = (x / (len(vis)-1)) * (max_steering - -max_steering) + -max_steering
    else:
        diff = left - right
        steering = -np.clip(diff / (max_vision - min_vision), -1.0, 1.0) * max_steering

    if is_reversing:
        steering = np.clip(steering - np.sign(steering), -1.0, 1.0)

    if abs(steering) < steer_deadzone:
        steering = 0.0

    speed += do_boost
    return np.array([[speed, steering]], dtype=np.float32), is_reversing

# ——— main ———
pygame.init()
pygame.joystick.init()
if pygame.joystick.get_count() == 0:
    print("No joystick detected.")
    exit(1)
joy = pygame.joystick.Joystick(0)
joy.init()

vesc = VESC(serial_port="/dev/ttyACM0")
cfg = load_config()
vision_history  = deque(maxlen=cfg["HISTORY_SIZE"])
last_cfg_mtime  = os.path.getmtime(ACTION_CFG_PATH)
last_dist_mtime = 0
last_vis        = None

# ring buffer for smoothing distances
ring_buffer = np.zeros((SMOOTH_FRAMES, NB_RAYCAST), dtype=np.float32)
ring_idx     = 0
ring_count   = 0

is_autopilot  = False
is_reversing  = False
current_speed = 0.0
current_steer = STEERING_CENTER
paused        = False

print("Press B to toggle MANUAL <-> AUTOPILOT, A to PAUSE/RESUME")

try:
    while True:
        # handle joystick events
        for evt in pygame.event.get():
            if evt.type == pygame.QUIT:
                raise KeyboardInterrupt
            if evt.type == pygame.JOYBUTTONDOWN:
                if evt.button == BUTTON_B:
                    is_autopilot = not is_autopilot
                    print(f"[INFO] Mode {'AUTOPILOT' if is_autopilot else 'MANUAL'}")
                elif evt.button == BUTTON_A:
                    paused = not paused
                    if paused:
                        vesc.set_duty_cycle(0)
                        vesc.set_servo(STEERING_CENTER)
                        print("[INFO] Paused – outputs zeroed")
                    else:
                        print("[INFO] Resumed")

        if paused:
            time.sleep(LOOP_DELAY)
            continue

        # reload config if changed
        m = os.path.getmtime(ACTION_CFG_PATH)
        if m != last_cfg_mtime:
            cfg = load_config()
            vision_history = deque(maxlen=cfg["HISTORY_SIZE"])
            last_cfg_mtime = m
            print("[INFO] Reloaded config")

        if is_autopilot:
            # read and parse distances
            if os.path.exists(DIST_FILE_PATH):
                m2 = os.path.getmtime(DIST_FILE_PATH)
                if m2 != last_dist_mtime:
                    last_dist_mtime = m2
                    txt = open(DIST_FILE_PATH).read().strip()
                    parts = [float(x) for x in txt.split(",") if x]
                    if len(parts) == NB_RAYCAST:
                        last_vis = np.array(parts, dtype=np.float32)
                    else:
                        print(f"[WARN] Expected {NB_RAYCAST} values, got {len(parts)}")

            if last_vis is not None:
                # update ring buffer
                ring_buffer[ring_idx] = last_vis
                ring_idx = (ring_idx + 1) % SMOOTH_FRAMES
                ring_count = min(ring_count + 1, SMOOTH_FRAMES)
                # compute smoothed vis
                vis_smooth = ring_buffer[:ring_count].mean(axis=0)

                action, is_reversing = get_action(vis_smooth, cfg, is_reversing)
                speed_target, steer_auto = action[0]
                target_servo = np.clip((-steer_auto)/2 + 0.5, 0.0, 1.0)
                target_speed = np.clip(speed_target, MIN_AUTO_SPEED, MAX_AUTO_SPEED)

                # speed ramp
                current_speed = ramp_speed(target_speed, current_speed,
                                           MAX_ACCEL_STEP, allow_negative=False)
                # direct steering
                current_steer = target_servo
        else:
            # manual control: instant response
            steer_in     = joy.get_axis(AXIS_STEER)
            current_steer = np.clip(STEERING_CENTER + steer_in * STEERING_RANGE/2,
                                    0.0, 1.0)
            lt = joy.get_axis(AXIS_LT)
            if lt != -1.0:
                current_speed = (lt + 1) * (REVERSE_SPEED/2)
            else:
                rt = joy.get_axis(AXIS_RT)
                current_speed = (rt + 1) * (MAX_SPEED/2)

        # send commands
        vesc.set_servo(current_steer)
        vesc.set_duty_cycle(current_speed)

        print(f"[{'AP' if is_autopilot else 'MAN'}] "
              f"spd={current_speed:.3f} str={current_steer:.3f}")

        time.sleep(LOOP_DELAY)

except KeyboardInterrupt:
    pass

finally:
    vesc.set_duty_cycle(0)
    vesc.set_servo(STEERING_CENTER)
    pygame.quit()
    print("Clean exit.")
